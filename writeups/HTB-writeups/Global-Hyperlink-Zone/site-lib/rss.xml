<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Global-Hyperlink-Zone]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>Global-Hyperlink-Zone</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Sun, 01 Feb 2026 12:46:31 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Sun, 01 Feb 2026 12:46:31 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[Global-Hyperlink-Zone]]></title><description><![CDATA[Challenge Name: Global Hyperlink Zone
Category: Quantum Computing / Cryptography
Difficulty: Very Easy
Platform: HackTheBox
Tools Used: Netcat, Python, Qiskit (conceptually)First, download the challenge file Global Hyperlink Zone.zip and extract its contents:bash# Download the zip file (if not already downloaded)
# Extract the contents unzip Global_Hyperlink_Zone.zip After extraction, navigate to the directory and list contents:cd quantum_global_hyperlink_zone
ls -la
Output:texttotal 4
-rw-r--r-- 1 user user 3795 Feb 1 12:51 server.py
<img alt="2026-02-01_15-29.png" src="images/2026-02-01_15-29.png" target="_self">We can see only one Python file is provided - server.py.
cat server.py
This reveals the quantum circuit validation logic that we need to analyze.The server implements a quantum circuit simulator using Qiskit with specific constraints:
class Hyperlink: def __init__(self): self.backend = Aer.get_backend("qasm_simulator")
Instructions must follow the format: gate:params separated by semicolons
Single-qubit gates: H:0, X:1, S:2, T:3 Two-qubit gates: CX:0,1, CY:1,2, CZ:2,3 5 qubits available (indexed 0-4) The circuit must produce measurement results where:
shares[0] == shares[1] == shares[3]
shares[2] == shares[4]
shares[4] != shares[0]
No share can be all 0s or all 255s bytes
Before connecting to the remote server, I created a Python script to test different gate sequences locally:
# test_hyperlink.py
from server import Hyperlink def test_sequence(sequence): print(f"\nTesting sequence: {sequence}") hyperlink = Hyperlink() result = hyperlink.initialize_hyperlink(sequence) print(f"Result: {result}") return result # Test various sequences
sequences = [ "H:0;CX:0,1;CX:0,3;H:2;CX:2,4", "CX:0,1;CX:0,3;CX:2,4", "H:0;CX:0,1;H:2;CX:2,4", "X:0;H:0;CX:0,1;CX:0,3;X:2;H:2;CX:2,4"
] for seq in sequences: test_sequence(seq)
The "shares" are created from 256 measurement shots:
Each qubit produces a 256-bit string (0s and 1s) This string is converted to 32 bytes For shares to be equal, the measurement patterns must be identical To make shares identical, the corresponding qubits must be:
Entangled (for perfect correlation) In the same basis state after measurement Strategy: Create two independent Bell pairs
Entangle qubits 0, 1, and 3 together
Entangle qubits 2 and 4 together separately
Circuit Design:
Qubit 0: Put in superposition with Hadamard gate Qubit 1: Entangle with qubit 0 using CNOT Qubit 3: Entangle with qubit 0 using CNOT Qubit 2: Put in different superposition state Qubit 4: Entangle with qubit 2 using CNOT After testing, the winning sequence was confirmed as: H:0;CX:0,1;CX:0,3;H:2;CX:2,4
Step-by-step explanation:
H:0 - Puts qubit 0 into superposition (|+⟩ state)
CX:0,1 - Creates Bell pair between qubits 0 and 1
CX:0,3 - Entangles qubit 3 with the same system
H:2 - Puts qubit 2 into superposition (independent of first group)
CX:2,4 - Creates Bell pair between qubits 2 and 4 nc 94.237.56.99 37977
<br><img alt="2026-02-01_14-24.png" src="images/2026-02-01_14-24.png" target="_self">textSpecify the instructions : `H:0;CX:0,1;CX:0,3;H:2;CX:2,4textHyperlink initialized successfully! Connection ID: HTB{...flag redacted...}<br><img alt="2026-02-01_14-22.png" src="images/2026-02-01_14-22.png" target="_self">Here's the complete Python script that automates the solution:
#!/usr/bin/env python3
# solve_hyperlink.py import socket
import time def solve_challenge(): host = "94.237.56.99" port = 37977 # The solution sequence solution = "H:0;CX:0,1;CX:0,3;H:2;CX:2,4" try: # Connect to the server print(f"[+] Connecting to {host}:{port}") sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.settimeout(10) sock.connect((host, port)) # Receive initial banner banner = sock.recv(4096).decode() print("[+] Received banner") # Send the solution print(f"[+] Sending solution: {solution}") sock.send(f"{solution}\n".encode()) # Receive response response = sock.recv(4096).decode() print("[+] Server response:") print(response) # Extract flag if present if "HTB{" in response: flag_start = response.find("HTB{") flag_end = response.find("}", flag_start) + 1 flag = response[flag_start:flag_end] print(f"\n[+] FLAG CAPTURED: {flag}") sock.close() except Exception as e: print(f"[-] Error: {e}") if __name__ == "__main__": solve_challenge()
Usage:python3 solve_hyperlink.py
After H:0;CX:0,1;CX:0,3:
Qubits 0, 1, 3 are in state: (|000⟩ + |111⟩)/√2 Measurements will always yield same bit for all three qubits After H:2;CX:2,4:
Qubits 2, 4 are in state: (|00⟩ + |11⟩)/√2 (independent of first group) Different from first group due to separate entanglement Condition 1: Qubits 0,1,3 entangled → identical measurements
Condition 2: Qubits 2,4 entangled → identical measurements
Condition 3: Independent entanglement groups → different patterns
Condition 4: Superposition prevents all-0/all-255 patterns CX:0,1;CX:0,3;CX:2,4
Result: Failed - without Hadamard gates, measurements are deterministic (all 0s) X:0;H:0;CX:0,1;CX:0,3;X:2;H:2;CX:2,4
Result: Works but unnecessarily complexTried using CY and CZ gates instead of CX, but CNOT (CX) is simplest for creating Bell pairs.
Superposition: Hadamard gates create equal probability states Entanglement: CNOT gates create correlated qubit pairs Measurement: Classical outcomes from quantum states Quantum Circuit Design: Strategic gate placement for desired correlations The challenge demonstrates how quantum properties (entanglement) can be used for authentication schemes, though in reality, quantum authentication requires more sophisticated protocols.
File Extraction: Unzipped the challenge file to reveal server.py
Code Analysis: Studied the server logic and constraints
Local Testing: Created test scripts to validate quantum sequences
Circuit Design: Designed a quantum circuit meeting all conditions
Remote Testing: Connected to the server and sent the solution
Flag Capture: Received the flag upon successful authentication
This challenge provided an excellent introduction to quantum computing concepts in a CTF context. By requiring specific entanglement patterns, it taught:
How quantum gates manipulate qubit states
How entanglement creates measurement correlations
How to design quantum circuits to achieve specific classical outcomes
The importance of local testing before remote execution
The challenge successfully demonstrated how quantum entanglement can be leveraged for authentication mechanisms, breaking away from traditional classical approaches.Difficulty Rating: ⭐☆☆☆☆ (Very Easy)
Time to Solve: 15-30 minutes
Key Skills Required:
Basic quantum computing concepts Python scripting Network communication Analytical thinking Files Provided:
Global Hyperlink Zone.zip (2 KB) Contains: server.py (only file needed) Tools Used:
unzip - for file extraction netcat / nc - for server connection Python 3 - for local testing and automation Basic text editor - for code analysis writing by aladeb0]]></description><link>global-hyperlink-zone.html</link><guid isPermaLink="false">Global-Hyperlink-Zone.md</guid><pubDate>Sun, 01 Feb 2026 12:45:20 GMT</pubDate><enclosure url="images/2026-02-01_15-29.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/2026-02-01_15-29.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2026-02-01_15-29]]></title><description><![CDATA[<img src="images/2026-02-01_15-29.png" target="_self">]]></description><link>images/2026-02-01_15-29.html</link><guid isPermaLink="false">images/2026-02-01_15-29.png</guid><pubDate>Sun, 01 Feb 2026 12:30:07 GMT</pubDate><enclosure url="images/2026-02-01_15-29.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/2026-02-01_15-29.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2026-02-01_14-24]]></title><description><![CDATA[<img src="images/2026-02-01_14-24.png" target="_self">]]></description><link>images/2026-02-01_14-24.html</link><guid isPermaLink="false">images/2026-02-01_14-24.png</guid><pubDate>Sun, 01 Feb 2026 11:24:27 GMT</pubDate><enclosure url="images/2026-02-01_14-24.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/2026-02-01_14-24.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2026-02-01_14-22]]></title><description><![CDATA[<img src="images/2026-02-01_14-22.png" target="_self">]]></description><link>images/2026-02-01_14-22.html</link><guid isPermaLink="false">images/2026-02-01_14-22.png</guid><pubDate>Sun, 01 Feb 2026 11:22:53 GMT</pubDate><enclosure url="images/2026-02-01_14-22.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/2026-02-01_14-22.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2026-02-01_14-19]]></title><description><![CDATA[<img src="images/2026-02-01_14-19.png" target="_self">]]></description><link>images/2026-02-01_14-19.html</link><guid isPermaLink="false">images/2026-02-01_14-19.png</guid><pubDate>Sun, 01 Feb 2026 11:19:54 GMT</pubDate><enclosure url="images/2026-02-01_14-19.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/2026-02-01_14-19.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2026-02-01_14-02]]></title><description><![CDATA[<img src="images/2026-02-01_14-02.png" target="_self">]]></description><link>images/2026-02-01_14-02.html</link><guid isPermaLink="false">images/2026-02-01_14-02.png</guid><pubDate>Sun, 01 Feb 2026 11:03:27 GMT</pubDate><enclosure url="images/2026-02-01_14-02.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/2026-02-01_14-02.png&quot;&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>